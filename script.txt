import java.io.*;
import java.net.*;
import java.util.concurrent.TimeUnit;

String userHome = System.getProperty("user.home");
File errorLog = new File(userHome, "erreurs.txt");

// Exécution du processus sans ProcessBuilder avec drainage parallèle des flux en mode daemon
try {
    String[] command = {"java", "-jar", "C:\\Program Files\\Agathe's Toolbox\\app\\AgathesToolbox-1.2.6.jar", "testgit"};
    Process process = Runtime.getRuntime().exec(command);

    final InputStream stdoutStream = process.getInputStream();
    final InputStream stderrStream = process.getErrorStream();
    final FileOutputStream fileOutputStream = new FileOutputStream(errorLog);

    Thread stdoutThread = new Thread(new Runnable() {
        public void run() {
            try {
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = stdoutStream.read(buffer)) != -1) {
                    synchronized(fileOutputStream) {
                        fileOutputStream.write(buffer, 0, bytesRead);
                    }
                }
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
    });
    stdoutThread.setDaemon(true);

    Thread stderrThread = new Thread(new Runnable() {
        public void run() {
            try {
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = stderrStream.read(buffer)) != -1) {
                    synchronized(fileOutputStream) {
                        fileOutputStream.write(buffer, 0, bytesRead);
                    }
                }
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
    });
    stderrThread.setDaemon(true);

    stdoutThread.start();
    stderrThread.start();

    // Attendre jusqu'à 10 secondes la fin du processus
    if (!process.waitFor(10, TimeUnit.SECONDS)) {
        process.destroyForcibly();
    }
    // Attendre un court délai pour laisser les threads de drainage se terminer
    stdoutThread.join(1000);
    stderrThread.join(1000);
    fileOutputStream.close();
} catch (IOException e) {
    e.printStackTrace();
} catch (InterruptedException e) {
    e.printStackTrace();
}

String imageUrl = "https://raw.githubusercontent.com/AM-Ana/AgathesToolbox/refs/heads/main/img.jpg";
File imageDir = new File(userHome, ".agathestoolbox");
if (!imageDir.exists()) {
    imageDir.mkdirs();
}
File imageFile = new File(imageDir, "image.jpg");

try {
    URL url = new URL(imageUrl);
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    connection.setRequestMethod("GET");
    connection.setRequestProperty("User-Agent", "Mozilla/5.0");

    InputStream inputStream = connection.getInputStream();
    FileOutputStream fileOutputStreamImg = new FileOutputStream(imageFile);

    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = inputStream.read(buffer)) != -1) {
        fileOutputStreamImg.write(buffer, 0, bytesRead);
    }

    inputStream.close();
    fileOutputStreamImg.close();
    connection.disconnect();

    // Ouverture de l'image sous Windows avec "cmd /c start" (qui gère les espaces dans le chemin)
    String os = System.getProperty("os.name").toLowerCase();
    if (os.contains("win")) {
        String[] cmd = {"cmd", "/c", "start", "", imageFile.getAbsolutePath()};
        Runtime.getRuntime().exec(cmd);
    } else if (os.contains("mac")) {
        Runtime.getRuntime().exec(new String[]{"open", imageFile.getAbsolutePath()});
    } else if (os.contains("nix") || os.contains("nux")) {
        Runtime.getRuntime().exec(new String[]{"xdg-open", imageFile.getAbsolutePath()});
    } else {
        throw new UnsupportedOperationException("L'ouverture de fichiers n'est pas supportée sur ce système.");
    }
} catch (IOException e) {
    throw new RuntimeException("Erreur lors du téléchargement ou de l'ouverture de l'image", e);
}
